[TOC]

# 1.关于接口和继承

> is a:
>
> 凡是类似Cat is a animal这种，一般来说“cat”和“animal”为继承关系，则可以将Cat和Animal描述为继承
>
> has a:
>
> 类似Customer has a menu，则“Customer”和“menu”是关联关系，则可以menu描述为Customer中的一个属性
>
> like a:
>
> 类似Cook like a menu，则“Cook”和“menu”是实现关系，将他们描述为类接口的实现，注意，这里的“像”不是长得像，而是功能上像

# 2.关于抽象类和接口

> 就目前来说，仅描述他们语法上的区别，在项目中使用他们还是要通过大量的经验来判断
>
> 抽象类是半抽象的/接口是完全抽象的
>
> 抽象类有构造方法/接口没有构造方法
>
> 抽象类之间只支持单继承/接口支持多继承
>
> 一个类可以实现多个接口，但是只能继承一个类
>
> 接口中只允许存在常量和抽象方法（可以省略public abstract）
>
> 接口使用会比抽象类多，接口一般是对“行为”的抽象

# 3.关于toString()方法

> SUN公司建议每个子类都要对toString()方法进行重写，应该详细且简单
>
> 在打印输出一个对象时，toString()方法会自动调用

# 4.关于equals()方法

> 判断两个基础数据类型是否相等，应该使用 ==
>
> 判断两个引用数据类型是否相等，应该使用equals方法
>
> 对于每个子类都应该重写equals方法

# 5.关于内部类

> 现在内部类已经基本不会使用，了解内部类仅为了读懂曾经使用这种方法编写的代码
>
> 内部类缺点：1.可读性差 2.只能用一次，代码复杂

# 6.关于StringBuffer和StringBuilder

> 这个两个类都可以实现拼接字符串的功能，但是StringBuffer中的方法都有synchronized关键字修饰，而StringBuilder中没有
>
> 这表示StringBuffer在多线程环境下是安全的，而StringBuilder是不安全的

# 7.关于枚举类型

> 当一个程序的运行结果可以一种一种列举出来时，如果只有两种情况，就使用boolean类型，超过两种情况，则使用枚举类
>
> 枚举类中只能存在常量，我们只要写常量名就行
>
> 高版本的jdk，swtich也支持枚举类型，但是尽量别用

# 8.进程和线程

> 1.进程，一个应用程序相当于一个进程
>
> 2.线程，线程是进程中的执行单元，一个进程可以有多个线程
>
> 不同的进程之间，内存独立不共享
>
> 在Java中，线程A和线程B，堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈



